{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#lshark-architecture-overview","title":"LSHARK \u2013 Architecture Overview","text":"<p>LSHARK is a modular loan and debt management system designed for Garry\u2019s Mod (DarkRP), built around a strict separation of responsibilities between core logic, data storage, networking, client interfaces, and public integrations. The system centralizes all critical operations on the server side, exposes a controlled and read-only public API for third-party addons, and relies on event-driven hooks to notify external systems about contract lifecycle changes. This architecture ensures stability, security, and extensibility, allowing other addons to integrate with LSHARK without direct access to internal database structures, networking layers, or business logic.</p> <pre>\n\ud83d\udcc1 lshark/\n\u251c\u2500\u2500 \ud83d\udcc1 lua/\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 autorun/\n\u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc4 lshark_loader.lua\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 entities/\n\u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc1 ent_auto_loan/\n\u2502   \u2502       \u251c\u2500\u2500 \ud83d\udcc4 cl_init.lua\n\u2502   \u2502       \u251c\u2500\u2500 \ud83d\udcc4 init.lua\n\u2502   \u2502       \u2514\u2500\u2500 \ud83d\udcc4 shared.lua\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 lshark/\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc1 api/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc4 sv_api.lua\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc1 client/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc1 tabs/\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 cl_tab_analytics.lua\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 cl_tab_contracts.lua\n\u2502   \u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 cl_tab_logs.lua\n\u2502   \u2502   \u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc4 cl_tab_management.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 cl_admin.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 cl_auto_loan.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 cl_boot.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 cl_client.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 cl_gui_framework.lua\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc4 cl_panel.lua\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc1 communication/\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc4 sv_notifications.lua\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc1 contracts/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 sv_contract_autocollect.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 sv_contract_manager.lua\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc4 sv_contract_storage.lua\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc1 core/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 sv_analytics.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 sv_database.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 sv_logs.lua\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc4 sv_network.lua\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc1 finance/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 sv_auto_loan.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 sv_lender_balance.lua\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc4 sv_manual_payments.lua\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc1 localization/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 lang_en.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 lang_br.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 lang_es.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 lang_fr.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 lang_de.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 lang_it.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 lang_pl.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 lang_ru.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 lang_tr.lua\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 language_manager.lua\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc4 sv_language_manager.lua\n\u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc4 settings.lua\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 weapons/\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 lshark_clipboard.lua\n\u251c\u2500\u2500 \ud83d\udcc1 materials/\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 entities/\n\u2502   \u2502   \u2514\u2500\u2500 \ud83d\uddbc\ufe0f auto_loan.png\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 gui/\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\uddbc\ufe0f contract.png\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\uddbc\ufe0f error.png\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\uddbc\ufe0f info.png\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\uddbc\ufe0f logo.png\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 logo.vmt\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\udcc4 logo.vtf\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\uddbc\ufe0f money.png\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\uddbc\ufe0f success.png\n\u2502   \u2502   \u251c\u2500\u2500 \ud83d\uddbc\ufe0f tips.png\n\u2502   \u2502   \u2514\u2500\u2500 \ud83d\uddbc\ufe0f warning.png\n\u2502   \u251c\u2500\u2500 \ud83d\udcc1 models/\n\u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc1 jason278/\n\u2502   \u2502       \u2514\u2500\u2500 \ud83d\udcc1 postal 2/\n\u2502   \u2502           \u2514\u2500\u2500 \ud83d\udcc1 weapons/\n\u2502   \u2502               \u251c\u2500\u2500 \ud83d\udcc4 clipboard_timb.vmt\n\u2502   \u2502               \u2514\u2500\u2500 \ud83d\udcc4 clipboard_timb.vtf\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 vgui/\n\u2502       \u2514\u2500\u2500 \ud83d\udcc1 entities/\n\u2502           \u251c\u2500\u2500 \ud83d\uddbc\ufe0f lshark_autoloan.png\n\u2502           \u2514\u2500\u2500 \ud83d\uddbc\ufe0f lshark_clipboard.png\n\u251c\u2500\u2500 \ud83d\udcc1 models/\n\u2502   \u2514\u2500\u2500 \ud83d\udcc1 postal 2/\n\u2502       \u2514\u2500\u2500 \ud83d\udcc1 weapons/\n\u2502           \u251c\u2500\u2500 \ud83d\udcc4 clipboard.dx80.vtx\n\u2502           \u251c\u2500\u2500 \ud83d\udcc4 clipboard.dx90.vtx\n\u2502           \u251c\u2500\u2500 \ud83d\udcc4 clipboard.mdl\n\u2502           \u251c\u2500\u2500 \ud83d\udcc4 clipboard.phy\n\u2502           \u251c\u2500\u2500 \ud83d\udcc4 clipboard.sw.vtx\n\u2502           \u2514\u2500\u2500 \ud83d\udcc4 clipboard.vvd\n\u2514\u2500\u2500 \ud83d\udcc1 sound/\n    \u2514\u2500\u2500 \ud83d\udcc1 lshark/\n        \u2514\u2500\u2500 \ud83d\udcc1 contract/\n            \u2514\u2500\u2500 \ud83c\udfb5 paper_sign.wav\n</pre>"},{"location":"#lshark_loaderlua-core-bootstrap-module-loader","title":"lshark_loader.lua \u2014 Core Bootstrap &amp; Module Loader","text":"<p>The <code>lshark_loader.lua</code> file is the central bootstrap of the entire LSHARK system and is responsible for initializing the global namespaces, validating the runtime environment, and orchestrating the loading order of all server-side and client-side modules. It enforces DarkRP compatibility at startup, initializes shared configuration (<code>settings.lua</code>), registers workshop dependencies, and defines helper utilities for controlled file loading with optional debug output. This loader guarantees a strict separation of concerns by loading core systems (database, logs, analytics, networking) before higher-level finance, contract, API, and communication layers, while also explicitly declaring which files are sent to clients. Its role is critical: without it, no other subsystem, API, hook, or UI component of LSHARK can function or be safely exposed.</p>"},{"location":"#loan-contract-entity-ent_auto_loan","title":"Loan Contract Entity (<code>ent_auto_loan</code>)","text":"<p>The Loan Contract Entity represents a physical, in-world manifestation of a loan contract inside Garry\u2019s Mod. It acts as an interaction anchor between players and the LSHARK loan system, visually and logically linking gameplay actions to the underlying contract mechanics.</p>"},{"location":"#sharedlua","title":"<code>shared.lua</code>","text":"<p>Defines the core metadata and identity of the entity, shared between server and client. This file declares the entity type, base class, spawn behavior, category, and spawn menu icon. It ensures the entity is correctly registered in Garry\u2019s Mod and recognized as a spawnable LSHARK component, without containing any logic or rendering code.</p> <p>Responsibilities: - Entity registration - Spawn menu configuration - Shared identity and classification  </p>"},{"location":"#initlua-server-side","title":"<code>init.lua</code> (Server-side)","text":"<p>Handles the server-side lifecycle and ownership logic of the entity. This file is responsible for initializing the entity in the world, assigning ownership, and ensuring it integrates correctly with DarkRP and the LSHARK backend systems.</p> <p>It acts as the server authority layer, guaranteeing that the entity exists as a valid contract-related object and can safely interact with server logic without exposing internal systems to the client.</p> <p>Responsibilities: - Server-side initialization - Ownership handling - Integration with gameplay rules and contract logic  </p>"},{"location":"#cl_initlua-client-side","title":"<code>cl_init.lua</code> (Client-side)","text":"<p>Implements the visual representation of the contract entity using a 3D2D interface. This file renders floating information above the entity, including the contract title, icon, and creditor name, while applying distance checks and optimized rendering to avoid unnecessary performance costs.</p> <p>No business logic or contract data manipulation occurs here; it is strictly presentation-focused.</p> <p>Responsibilities: - Client-side rendering - 3D2D visual interface - Performance-safe visual feedback  </p>"},{"location":"#public-server-api-sv_apilua","title":"Public Server API (<code>sv_api.lua</code>)","text":"<p>This file exposes the official public server-side API of LSHARK, designed for safe third-party integration. It provides read-only access to loan contract data while fully isolating internal systems such as database access, networking, and business logic.</p> <p>All functions are registered under the <code>LSHARK.API</code> namespace and are available server-side only. Contract data is always returned in a sanitized and stable format, ensuring external addons do not depend on internal schemas.</p> <p>The API is intended for administrative tools, analytics, restrictions, and external systems that need to observe the state of contracts without mutating them.</p>"},{"location":"#client-interface-layer-ui","title":"Client Interface Layer (UI)","text":"<p>The client layer of LSHARK is responsible for all user-facing interfaces, visual rendering, and interaction flow. It operates strictly as a presentation and interaction layer, containing no business rules, persistence logic, or authoritative state changes. All actions are executed through validated server communication.</p>"},{"location":"#cl_bootlua-client-bootstrap-ui-entry-point","title":"<code>cl_boot.lua</code> \u2014 Client Bootstrap &amp; UI Entry Point","text":"<p>Initializes the client-side UI environment. Defines shared helper utilities (currency and percentage parsing/formatting), registers the main menu command (<code>lshark_menu</code>), enforces job and equipment requirements, and mounts the core interface tabs. Also handles generic server notifications and requests the initial lender balance after client initialization.</p>"},{"location":"#cl_panellua-debtor-interface","title":"<code>cl_panel.lua</code> \u2014 Debtor Interface","text":"<p>Implements the debtor-facing panel used to view and manage personal debts. Renders a debt table, detailed contract inspection panel, and manual payment controls. All data is provided by the server, and all actions (payments, limits) are sent back via validated net messages. Contains no validation or financial logic; strictly UI and user input handling.</p>"},{"location":"#cl_clientlua-contract-reception-signing-flow","title":"<code>cl_client.lua</code> \u2014 Contract Reception &amp; Signing Flow","text":"<p>Handles the client-side contract interaction lifecycle. Receives contract offers from the server, builds presentation data, opens the contract signing interface, and captures accept/reject actions. Supports keyboard shortcuts and automatic opening for auto-loan contracts. All decisions and state changes are delegated to the server.</p>"},{"location":"#cl_auto_loanlua-auto-loan-interface","title":"<code>cl_auto_loan.lua</code> \u2014 Auto Loan Interface","text":"<p>Implements the automatic loan creation UI. Allows players to simulate loan values, installments, interest, penalties, and available credit using server-supplied configuration limits. Maintains local caches for configuration and existing debt strictly for visual previews. All calculations are non-authoritative; final validation and contract creation occur server-side.</p>"},{"location":"#cl_adminlua-administrative-interface","title":"<code>cl_admin.lua</code> \u2014 Administrative Interface","text":"<p>Provides the administrative contract management UI. Displays all contracts, supports filtering and inspection, and allows deletion through confirmed server requests. Acts purely as an administrative presentation layer with no local authority over contract state.</p>"},{"location":"#cl_gui_frameworklua-gui-framework-core","title":"<code>cl_gui_framework.lua</code> \u2014 GUI Framework Core","text":"<p>Defines the shared UI framework used across all client interfaces. Provides dynamic scaling, centralized font management, a global color palette, and reusable UI primitives such as frames, tables, buttons, popups, and specialized components. Includes custom text rendering utilities for advanced layouts. Contains no business logic; responsible only for layout, styling, and UI composition.</p>"},{"location":"#cl_tab_managementlua-loan-management-tab","title":"<code>cl_tab_management.lua</code> \u2014 Loan Management Tab","text":"<p>Implements the lender management interface. Allows configuration of auto-loan parameters, management of lender balance (deposit/withdraw), and creation of manual loan offers. All previews are client-side only; limits, cooldowns, and contract creation are enforced server-side.</p>"},{"location":"#cl_tab_contractslua-contracts-overview-tab","title":"<code>cl_tab_contracts.lua</code> \u2014 Contracts Overview Tab","text":"<p>Displays a consolidated view of all contracts with status-aware visuals. Provides detailed inspection of selected contracts and supports lifecycle actions (toggle, refresh, delete) through validated server messages. Serves as the primary contract inspection UI without local authority.</p>"},{"location":"#cl_tab_logslua-activity-logs-tab","title":"<code>cl_tab_logs.lua</code> \u2014 Activity Logs Tab","text":"<p>Implements the audit and activity log viewer. Receives serialized log data from the server, provides real-time search and sorting, and supports manual refresh. All logs are generated and classified server-side.</p>"},{"location":"#cl_tab_analyticslua-analytics-statistics-dashboard","title":"<code>cl_tab_analytics.lua</code> \u2014 Analytics &amp; Statistics Dashboard","text":"<p>Implements the financial analytics dashboard using an embedded HTML (Chart.js) interface. Displays KPIs, time-series charts, profit/loss indicators, and interactive time-range selection. Processes server-provided analytics data strictly for visualization, with no local financial authority.</p> <p>Summary: The client layer of LSHARK is intentionally thin, modular, and non-authoritative. Its sole responsibility is to translate server-controlled state into clear, responsive, and localized user interfaces, while delegating all validation, persistence, and security decisions to the server.</p>"},{"location":"#communication","title":"communication","text":""},{"location":"#sv_notificationslua-server-notifications-player-feedback","title":"sv_notifications.lua \u2014 Server Notifications &amp; Player Feedback","text":"<p>This file implements the server-side notification and feedback layer of LSHARK, responsible for sending contextual messages and guidance to players based on server-side events and interactions. It centralizes non-intrusive communication logic without exposing business rules or internal systems.</p> <p>The module defines a controlled helper for dispatching notifications to clients via the <code>LSHARK_Notification</code> network channel, allowing the server to trigger informational, warning, or tip messages that are rendered client-side through the UI framework.</p> <p>It also registers lightweight chat command shortcuts, enabling players to open the debtor panel by typing <code>lshark</code> (or common typo variations) directly in chat. This improves accessibility while remaining fully server-controlled.</p> <p>Additionally, the file listens for job change events (<code>OnPlayerChangedTeam</code>) and checks them against configured lender job rules. When a player becomes eligible as a lender, a contextual tip notification is sent, informing them of newly available LSHARK features.</p> <p>Overall, this file acts as the server-driven user guidance and notification bridge, enhancing usability and discoverability while maintaining strict separation from contract logic, persistence, and validation systems.</p>"},{"location":"#contracts","title":"contracts","text":""},{"location":"#sv_contract_storagelua-contract-persistence-database-access-layer","title":"sv_contract_storage.lua \u2014 Contract Persistence &amp; Database Access Layer","text":"<p>This file implements the server-side persistence layer for LSHARK loan contracts. It is responsible exclusively for storing, retrieving, updating, and deleting contract data in the local SQLite database, acting as the single source of truth for contract state persistence.</p> <p>The module provides a set of well-defined database helper functions under the <code>LSHARK.DB_*</code> namespace, encapsulating all SQL operations and shielding the rest of the system from raw database queries. Input values are sanitized and normalized before execution, and all write operations are executed through a protected wrapper to prevent server crashes caused by SQL errors.</p> <p>Core responsibilities include: - Inserting and updating full contract records. - Fetching contracts by code, creditor, debtor, or status. - Persisting payment progress, remaining balance, and contract status. - Supporting administrative operations such as full listings, deletion, and global cleanup. - Toggling contract state (active \u2194 paused) in a controlled manner.</p> <p>This file contains no business rules, validation logic, or gameplay decisions. It serves strictly as the data storage backend, enabling higher-level systems (contract manager, auto-collection, analytics, API) to operate on reliable, persistent contract data without direct database coupling.</p>"},{"location":"#sv_contract_managerlua-contract-validation-lifecycle-authority-layer","title":"sv_contract_manager.lua \u2014 Contract Validation, Lifecycle &amp; Authority Layer","text":"<p>This file implements the core server-side contract management layer of LSHARK. It acts as the authoritative controller for the entire contract lifecycle, handling validation, creation, acceptance, rejection, status changes, deletion, and administrative actions. All contract-related decisions pass through this module.</p> <p>The module validates job permissions, financial limits, interest and fine constraints, installment rules, and available balance before allowing any contract to be issued. Both manual and auto-loan contracts are supported, with auto-loans enforcing additional configuration-based restrictions.</p> <p>Contracts are first stored in a pending state and only become persistent after explicit debtor acceptance. Upon acceptance, the module performs balance transfers, persists the contract through the storage layer, registers logs and analytics events, and triggers system-wide hooks for external integrations.</p> <p>The file also manages: - Contract acceptance and rejection flow. - Controlled toggling of contract status (active, paused, capped, paid). - Creditor-owned contract deletion. - Full administrative contract inspection and deletion. - Server notifications for all contract outcomes. - Emission of lifecycle hooks (<code>LSHARK_ContractCreated</code>, <code>LSHARK_ContractStatusChanged</code>, <code>LSHARK_ContractDeleted</code>) for extensibility.</p> <p>No client input is trusted directly. This file is the central authority enforcing rules, integrity, and consistency across all contract operations in LSHARK, coordinating storage, finance, analytics, logging, notifications, and public hooks.</p>"},{"location":"#sv_contract_autocollectlua-automatic-debt-processing-enforcement-engine","title":"sv_contract_autocollect.lua \u2014 Automatic Debt Processing &amp; Enforcement Engine","text":"<p>This file implements the automatic debt collection system of LSHARK and is one of the most critical server-side enforcement components. It is responsible for periodically processing debtor contracts, applying automatic payments, partial payments, penalties, debt caps, and final contract resolution in a fully server-authoritative manner.</p> <p>The module evaluates each active or capped contract for online players at fixed intervals, calculating how much can be safely debited based on the debtor\u2019s available cash and configured auto-debit limits. When possible, installments are automatically paid and credited to the lender\u2019s balance; otherwise, fines or partial payments are applied according to contract rules.</p> <p>Key responsibilities include: - Enforcing debtor auto-debit limits and percentage caps. - Applying installment payments, partial payments, or fines when payments fail. - Capping debt growth based on job-defined loan multipliers. - Marking contracts as paid, capped, or limited when thresholds are reached. - Registering logs and analytics events for every automated action. - Emitting lifecycle hooks (<code>LSHARK_InstallmentPaid</code>, <code>LSHARK_FineApplied</code>, <code>LSHARK_ContractPaidOff</code>, <code>LSHARK_LimitedContract</code>) for external integrations.</p> <p>The system runs on a configurable server timer and restarts automatically on map load or cleanup. A debug-only command is provided to force immediate processing during development or testing.</p> <p>This file acts as the automated enforcement engine of LSHARK, ensuring debts evolve consistently, fairly, and predictably over time without client involvement, while maintaining full auditability and extensibility.</p>"},{"location":"#core","title":"core","text":""},{"location":"#sv_databaselua-core-database-initialization-low-level-access","title":"sv_database.lua \u2014 Core Database Initialization &amp; Low-Level Access","text":"<p>This file defines the database foundation of LSHARK. It is responsible for initializing all required SQLite tables, creating indexes, and exposing a minimal set of low-level database helpers used by higher-level storage and core systems. </p> <p>On server startup, the module ensures that every persistence table required by LSHARK exists, including contracts, balances, logs, analytics events, auto-loan configuration, debtor limits, and limited-contract tracking. Indexes are created for frequently queried fields to improve lookup performance and scalability.</p> <p>The file also exposes controlled helper functions for executing queries, fetching result sets, and checking record existence. These helpers act as a thin abstraction layer over Garry\u2019s Mod\u2019s SQLite API, allowing other modules to interact with the database without duplicating boilerplate or unsafe SQL handling.</p> <p>No business logic, validation rules, or gameplay decisions are present in this file. It serves strictly as the core persistence bootstrap and database utility layer, upon which all other server-side storage, analytics, logging, and contract systems depend.</p>"},{"location":"#sv_analyticslua-financial-analytics-event-tracking-core","title":"sv_analytics.lua \u2014 Financial Analytics &amp; Event Tracking Core","text":"<p>This file implements the server-side analytics system of LSHARK. It is responsible for recording, storing, maintaining, and serving financial and contract-related events that feed the client analytics dashboard and administrative insights.</p> <p>The module exposes a controlled API to register analytics events tied to a player and contract, capturing loaned amounts, received payments, open balances, and event timestamps. All events are persisted in the analytics table using normalized Unix timestamps to ensure consistent chronological processing.</p> <p>To maintain performance and data relevance, the file includes automated cleanup routines that limit the number of tracked contracts per player and remove orphaned analytics entries when contracts no longer exist. These routines run periodically and on server initialization without player involvement.</p> <p>The module also handles client analytics requests, serializing and sending the complete event timeline for the requesting player in JSON format. No aggregation or visualization logic exists here; all higher-level interpretation is performed client-side.</p> <p>This file functions as the analytics data backbone of LSHARK, providing a clean, bounded, and reliable event history that supports dashboards, audits, and external integrations without affecting core gameplay logic.</p>"},{"location":"#sv_logslua-audit-logs-event-history-core","title":"sv_logs.lua \u2014 Audit Logs &amp; Event History Core","text":"<p>This file implements the server-side logging system of LSHARK. It is responsible for recording, storing, maintaining, and serving audit logs related to contracts, payments, penalties, and administrative actions, providing a reliable historical trail for users and administrators.</p> <p>The module exposes a controlled function (<code>LSHARK.RegisterLog</code>) used by other server systems to persist log entries associated with a player and, optionally, a specific contract. Each log entry records the event type, human-readable message, and timestamp, ensuring traceability of all relevant actions.</p> <p>It also handles client log requests, returning a capped, ordered list of recent log entries for the requesting player. Logs are sent in a pre-serialized format optimized for client-side rendering, without exposing database internals.</p> <p>To preserve performance and storage health, the file includes automated maintenance routines: - Periodic cleanup to limit the maximum number of logs stored per player. - Removal of orphaned log entries when related contracts no longer exist. - Automatic pruning of invalid or empty contract references.</p> <p>This file contains no gameplay logic or validation rules. It functions strictly as the audit and traceability backbone of LSHARK, ensuring transparency, accountability, and historical insight across all financial and contractual operations.</p>"},{"location":"#sv_networklua-network-channel-registration-communication-boundary","title":"sv_network.lua \u2014 Network Channel Registration &amp; Communication Boundary","text":"<p>This file defines the network communication boundary of LSHARK. It centralizes the registration of all network strings used for client\u2013server communication, ensuring that every message channel is explicitly declared, organized, and auditable. </p> <p>The module groups network channels by functional domain, including user interface actions, contract lifecycle operations, administrative controls, analytics and logs, auto-loan systems, balance management, and debtor interactions. This structure enforces clarity and prevents ad-hoc or duplicated network definitions across the codebase.</p> <p>No message handling, validation, or logic is implemented here. The file exists solely to declare and expose the allowed communication channels, serving as a strict interface contract between the client and server layers.</p> <p>By centralizing all <code>util.AddNetworkString</code> calls, this file strengthens maintainability, security, and code reviewability, making it clear which interactions are permitted and where they are handled.</p>"},{"location":"#finance","title":"finance","text":""},{"location":"#sv_manual_paymentslua-manual-debt-payments-debtor-controls","title":"sv_manual_payments.lua \u2014 Manual Debt Payments &amp; Debtor Controls","text":"<p>This file implements the server-side manual payment system of LSHARK. It handles all debtor-initiated payments, allowing players to manually settle debts by amount or by installments while enforcing full server authority over validation, balance updates, and contract state changes. </p> <p>The module validates debtor identity, contract ownership, available funds, remaining balance, and payment method before applying any transaction. It supports both full and partial payments, correctly updating installments paid, advanced installments, remaining balance, and final contract status when fully settled.</p> <p>In addition, the file manages debtor auto-debit limits, allowing players to configure how much of their balance can be used for automatic collections. These limits are persisted server-side and respected by the automatic debt processing engine.</p> <p>Every manual payment triggers: - Contract state updates in persistent storage. - Secure money transfer between debtor and creditor balance. - Log registration for auditability. - Analytics event registration for financial tracking. - User notifications for both debtor and creditor.</p> <p>This file contains no client-side logic and does not trust client input. It serves as the authoritative manual settlement and debtor control layer, complementing the automatic collection system while maintaining consistency, traceability, and financial integrity.</p>"},{"location":"#sv_lender_balancelua-lender-balance-management-internal-wallet","title":"sv_lender_balance.lua \u2014 Lender Balance Management &amp; Internal Wallet","text":"<p>This file implements the server-side lender balance system of LSHARK. It manages the internal wallet used by creditors to fund loans, receive repayments, and perform balance transfers independently from the player\u2019s DarkRP cash. </p> <p>The module defines a persistent balance per SteamID and exposes controlled helper functions to query, add, set, and deduct balance values while preventing invalid or negative states. Balance rows are created lazily to ensure data consistency without manual initialization.</p> <p>It also handles client-initiated balance operations, allowing lenders to deposit DarkRP money into their LSHARK balance or withdraw funds back to their wallet. All transactions are validated server-side, enforcing sufficient funds and valid amounts before any transfer occurs.</p> <p>After each operation, the updated balance is sent back to the client, keeping the UI synchronized with the authoritative server state. Notifications are emitted to inform the player of successful or failed actions.</p> <p>This file contains no contract logic or gameplay rules. It functions strictly as the financial wallet and balance authority layer for lenders, forming the monetary backbone that supports contract creation, repayments, and analytics across the LSHARK system.</p>"},{"location":"#sv_auto_loanlua-automatic-loan-configuration-issuance-core","title":"sv_auto_loan.lua \u2014 Automatic Loan Configuration &amp; Issuance Core","text":"<p>This file implements the server-side automatic loan system of LSHARK. It is responsible for storing auto-loan configurations, validating auto-loan requests, calculating limits, and issuing auto-generated contracts under strict server authority. </p> <p>The module persists per-creditor auto-loan settings, including maximum loan amount, maximum installments, interest rate, and penalty rate. These configurations are securely stored and retrieved from the database and exposed to clients only in a sanitized, read-only form for interface previews.</p> <p>It provides helper functions to: - Load and normalize auto-loan configuration data. - Calculate active debt between a specific debtor and creditor. - Enforce credit limits and installment constraints before issuing a loan.</p> <p>The file handles all auto-loan network requests, including configuration retrieval, debt queries, and loan submission. Before creating any contract, it validates that the requested amount does not exceed configured limits or existing debt capacity.</p> <p>When an auto-loan request is approved, the module delegates contract creation to the central contract manager, generating standardized auto-loan contracts with consistent metadata and lifecycle handling.</p> <p>This file contains no client-side logic and does not trust client input. It serves as the configuration, validation, and issuance layer for automatic loans, tightly integrated with balance management, contract enforcement, analytics, and logging systems.</p>"},{"location":"#localization-system-i18n","title":"Localization System (I18N)","text":"<p>The localization layer of LSHARK provides a unified and extensible internationalization system, ensuring that all user-facing text is language-aware, consistent, and configurable at runtime. It is designed to work transparently across client and server, without embedding hardcoded strings in business or UI logic.</p>"},{"location":"#language_managerlua-client-language-manager","title":"<code>language_manager.lua</code> \u2014 Client Language Manager","text":"<p>Implements the client-side localization controller. Responsible for registering language packs, selecting the active language, resolving translation keys, and formatting localized strings with parameters.</p> <p>The manager supports graceful fallback to English when a key is missing and automatically applies the language defined in <code>settings.lua</code> during client initialization. All UI components access translations exclusively through this layer.</p>"},{"location":"#sv_language_managerlua-server-language-manager","title":"<code>sv_language_manager.lua</code> \u2014 Server Language Manager","text":"<p>Implements the server-side localization controller, mirroring the client behavior for server-originated messages such as notifications, logs, and chat output.</p> <p>The active language is loaded from server configuration and applied globally, ensuring consistency between server messages and client UI text.</p>"},{"location":"#language-packs","title":"Language Packs","text":"<p>Each language file registers a dictionary of translation keys mapped to localized strings. They contain no logic, only structured key\u2013value pairs.</p> <p>Supported languages:</p> <ul> <li><code>lang_en.lua</code> \u2014 English (default / fallback)</li> <li><code>lang_br.lua</code> \u2014 Portuguese (Brazil)</li> <li><code>lang_es.lua</code> \u2014 Spanish</li> <li><code>lang_fr.lua</code> \u2014 French</li> <li><code>lang_de.lua</code> \u2014 German</li> <li><code>lang_it.lua</code> \u2014 Italian</li> <li><code>lang_pl.lua</code> \u2014 Polish</li> <li><code>lang_ru.lua</code> \u2014 Russian</li> <li><code>lang_tr.lua</code> \u2014 Turkish</li> </ul> <p>Summary: The localization system centralizes all translatable text, enforces consistent language resolution across client and server, and allows LSHARK to be deployed in multilingual environments without modifying core logic or interfaces.</p>"},{"location":"#settingslua-global-configuration-rule-definition","title":"settings.lua \u2014 Global Configuration &amp; Rule Definition","text":"<p>This file defines the central configuration layer of LSHARK. It is the single source of truth for system behavior, limits, intervals, language selection, and job-specific financial rules. All server-side validation logic ultimately derives its constraints from this file. </p>"},{"location":"#general-settings","title":"General Settings","text":"<p>The <code>General</code> section controls global system behavior and default safeguards:</p> <ul> <li>DebugMode: Enables development-only features and verbose output. Must remain disabled in production.</li> <li>Language: Defines the default language used by both client and server localization systems.</li> <li>DefaultDebtDiscount: Percentage of a debtor\u2019s balance eligible for automatic debt collection.</li> <li>AutoDebtProcessingInterval: Time interval (in seconds) for automatic debt processing cycles.</li> </ul> <p>It also defines global fallback limits, applied when a job has no specific override: - Maximum total interest - Maximum interest per installment - Maximum late fee percentage - Maximum number of installments - Maximum debt multiplier over the original loan value</p> <p>These values act as baseline safety limits to prevent abusive or unstable configurations.</p>"},{"location":"#joblimits-profession-based-rules","title":"JobLimits \u2014 Profession-Based Rules","text":"<p>The <code>JobLimits</code> section defines job-specific financial rules that override global defaults. Each job entry controls how that profession may issue loans, including:</p> <ul> <li>MaxInterest: Base guaranteed cap for total interest.</li> <li>MaxInterestPerInstallment: Per-installment interest ceiling.</li> <li>MaxFine: Maximum late payment penalty percentage.</li> <li>MaxLoanInstallments: Upper bound for installment count.</li> <li>MaxLoanMultiplier: Absolute cap on total debt growth.</li> </ul> <p>The effective maximum interest is dynamically calculated as the greater of: - <code>MaxInterest</code> - <code>MaxInterestPerInstallment \u00d7 NumberOfInstallments</code></p> <p>This model allows flexible scaling for long-term contracts while still protecting short-term loans from extreme rates.</p> <p>If accumulated interest or fines exceed the multiplier cap, the contract is automatically capped, and further penalties are disabled to prevent infinite debt growth.</p>"},{"location":"#role-in-the-architecture","title":"Role in the Architecture","text":"<p>This file contains no logic and performs no runtime actions. Its responsibility is strictly declarative.</p> <p>All validation, enforcement, auto-collection, contract creation, and UI previews rely on these values, making <code>settings.lua</code> the policy backbone of the entire LSHARK system.</p> <p>Changing this file alters system behavior globally without requiring code changes elsewhere.</p>"},{"location":"#clipboard-swep","title":"Clipboard SWEP","text":""},{"location":"#lshark_clipboardlua-lshark-clipboard-swep-ui-access-tool","title":"lshark_clipboard.lua \u2014 LSHARK Clipboard SWEP (UI Access Tool)","text":"<p>This file implements the LSHARK clipboard SWEP, which serves as the physical interaction tool that grants players access to the LSHARK management interface. It bridges in-world gameplay interaction with the client UI layer, without embedding any business or financial logic. </p> <p>The weapon is configured as a utility SWEP, using a clipboard world model and custom iconography to visually represent contract handling. It disables combat-related features such as ammo, crosshair, and damage, reinforcing its purely administrative purpose.</p> <p>On the client side, the SWEP handles custom viewmodel and worldmodel rendering, replacing the default weapon model with a properly aligned clipboard using bone-based positioning and transformation matrices. This ensures consistent visual presentation in both first-person and third-person views.</p> <p>The primary action (<code>PrimaryAttack</code>) is server-authoritative and simply triggers the <code>lshark_menu</code> console command, opening the main LSHARK interface if the player meets all server-side permission checks. A small cooldown prevents interaction spam, and an audio cue provides immediate feedback.</p> <p>No contract logic, validation, or state mutation exists in this file. Its responsibility is strictly UI access and visual representation, acting as the final interaction layer that connects players to the LSHARK system in a natural, immersive way.</p>"},{"location":"api/contract-model/","title":"Contract Model &amp; Database Structures","text":"<p>This document describes the LSHARK contract model (what a contract is, its fields, and how they are interpreted), and then documents the SQLite tables used by LSHARK.</p>"},{"location":"api/contract-model/#contract-model","title":"Contract Model","text":"<p>In LSHARK, a contract is the authoritative server record representing a loan agreement between a creditor and a debtor, including its terms (principal, interest, fine, installments) and its evolving state (paid amounts, remaining balance, status).</p> <p>Contracts are persisted in SQLite in the <code>LSHARK_CONTRACTS</code> table and are treated as the single source of truth for debt enforcement, UI displays, logs, and analytics.</p>"},{"location":"api/contract-model/#contract-status-values","title":"Contract Status Values","text":"<p>A contract\u2019s <code>status</code> represents its current operational state:</p> <ul> <li>active: normal contract; installments and fines may apply.</li> <li>paused: temporarily disabled; typically excluded from automatic processing.</li> <li>paid: fully settled; remaining balance is zero.</li> <li>capped: debt growth has reached the configured multiplier ceiling; additional fines are typically disabled and the debt is clamped.</li> </ul>"},{"location":"api/contract-model/#contract-structure-raw","title":"Contract Structure (Raw)","text":""},{"location":"api/contract-model/#sqlite-row-schema-lshark_contracts","title":"SQLite Row Schema: <code>LSHARK_CONTRACTS</code>","text":"<pre><code>LSHARK_CONTRACTS\n\u251c\u2500 code (TEXT, PRIMARY KEY)\n\u251c\u2500 creditor (TEXT)\n\u251c\u2500 creditor_steamid (TEXT)\n\u251c\u2500 debtor (TEXT)\n\u251c\u2500 debtor_steamid (TEXT)\n\u251c\u2500 creditor_job (TEXT)\n\u251c\u2500 amount (REAL DEFAULT 0)\n\u251c\u2500 interest (REAL DEFAULT 0)\n\u251c\u2500 fine (REAL DEFAULT 0)\n\u251c\u2500 installments (INTEGER DEFAULT 1)\n\u251c\u2500 installments_paid (INTEGER DEFAULT 0)\n\u251c\u2500 installments_advanced (INTEGER DEFAULT 0)\n\u251c\u2500 total_with_interest (REAL DEFAULT 0)\n\u251c\u2500 total_paid (REAL DEFAULT 0)\n\u251c\u2500 remaining_balance (REAL DEFAULT 0)\n\u251c\u2500 status (TEXT DEFAULT 'active')\n\u2514\u2500 created_at (TEXT)\n</code></pre>"},{"location":"api/contract-model/#field-semantics","title":"Field Semantics","text":""},{"location":"api/contract-model/#identity","title":"Identity","text":"<ul> <li>code   Unique contract identifier (primary key). Used across the entire system as the stable reference for payments, logs, analytics, and admin actions.</li> </ul>"},{"location":"api/contract-model/#parties","title":"Parties","text":"<ul> <li> <p>creditor, creditor_steamid   Creditor display name and SteamID. SteamID is the authoritative identifier; the name is for display/auditing.</p> </li> <li> <p>debtor, debtor_steamid   Debtor display name and SteamID. SteamID is used for ownership validation, queries, and enforcement.</p> </li> <li> <p>creditor_job   Job name captured at creation time. Used for policy context (limits and multiplier rules) and for audit visibility.</p> </li> </ul>"},{"location":"api/contract-model/#financial-terms","title":"Financial Terms","text":"<ul> <li> <p>amount   Principal (original loaned value).</p> </li> <li> <p>interest   Interest percentage applied to the loan (stored as a percentage value). Depending on the contract type, this may already represent the total interest for the full contract.</p> </li> <li> <p>fine   Late fee percentage applied on missed/partial installment processing, usually calculated on top of the remaining balance.</p> </li> <li> <p>installments   Total number of installments agreed in the contract.</p> </li> </ul>"},{"location":"api/contract-model/#accounting-progress","title":"Accounting &amp; Progress","text":"<ul> <li> <p>total_with_interest   Total debt value after applying interest to the principal (baseline total before late fees).</p> </li> <li> <p>total_paid   Total amount already paid into this contract (sum of all payments recorded by LSHARK).</p> </li> <li> <p>remaining_balance   Current unpaid balance. Decreases with payments, may increase with fines until capped by the multiplier rule, and becomes <code>0</code> when the contract is fully settled.</p> </li> <li> <p>installments_paid   Count of installments successfully paid so far. Used for progress tracking and status transitions.</p> </li> <li> <p>installments_advanced   Tracks installments treated as \u201cadvanced/covered\u201d by the payment logic. This value must not exceed <code>installments_paid</code>, and is used to keep installment progression consistent when special installment handling exists.</p> </li> </ul>"},{"location":"api/contract-model/#state-metadata","title":"State &amp; Metadata","text":"<ul> <li> <p>status   Operational state string (see status values above).</p> </li> <li> <p>created_at   Creation timestamp stored as text (used for auditing and UI display).</p> </li> </ul>"},{"location":"api/contract-model/#contract-structure-example","title":"Contract Structure (Example)","text":""},{"location":"api/contract-model/#example-contract-row-conceptual","title":"Example Contract Row (Conceptual)","text":"<pre><code>{\n  code = \"AUTO-123456\",\n  creditor = \"Banker Bob\",\n  creditor_steamid = \"STEAM_0:1:11111111\",\n  debtor = \"Player Alice\",\n  debtor_steamid = \"STEAM_0:0:22222222\",\n  creditor_job = \"Banker\",\n  amount = 5000,\n  interest = 40,\n  fine = 2,\n  installments = 10,\n  installments_paid = 3,\n  installments_advanced = 3,\n  total_with_interest = 7000,\n  total_paid = 2100,\n  remaining_balance = 4900,\n  status = \"active\",\n  created_at = \"2026-01-03 21:00:00\"\n}\n</code></pre>"},{"location":"api/contract-model/#related-database-structures","title":"Related Database Structures","text":"<p>LSHARK uses additional tables for internal wallets, logs, analytics, auto-loan settings, debtor limits, and capped contract tracking.</p>"},{"location":"api/contract-model/#1-lender-balance-wallet-lshark_balance","title":"1) Lender Balance Wallet: <code>LSHARK_BALANCE</code>","text":"<p>Stores an internal lender wallet per SteamID (separate from DarkRP cash).</p> <pre><code>LSHARK_BALANCE\n\u251c\u2500 steamid (TEXT, PRIMARY KEY)\n\u2514\u2500 balance (REAL DEFAULT 0)\n</code></pre> <p>Purpose: - Holds lender funds used to issue loans and receive repayments. - Supports deposit/withdraw flows between DarkRP money and the internal balance.</p>"},{"location":"api/contract-model/#2-audit-logs-lshark_logs","title":"2) Audit Logs: <code>LSHARK_LOGS</code>","text":"<p>Stores server-generated log entries for transparency and debugging.</p> <pre><code>LSHARK_LOGS\n\u251c\u2500 id (INTEGER, PRIMARY KEY AUTOINCREMENT)\n\u251c\u2500 steamid (TEXT)\n\u251c\u2500 contract_code (TEXT)\n\u251c\u2500 type (TEXT)\n\u251c\u2500 message (TEXT)\n\u2514\u2500 timestamp (TEXT)\n</code></pre> <p>Purpose: - Keeps a chronological history of actions (payments, fines, contract changes, admin actions). - Feeds the client \u201cActivity Logs\u201d tab.</p> <p>Notes: - <code>contract_code</code> links logs back to <code>LSHARK_CONTRACTS.code</code> when applicable. - Cleanup routines may prune old logs and remove orphaned rows when contracts are missing.</p>"},{"location":"api/contract-model/#3-analytics-events-lshark_analytics","title":"3) Analytics Events: <code>LSHARK_ANALYTICS</code>","text":"<p>Stores event-based financial tracking used by the analytics dashboard.</p> <pre><code>LSHARK_ANALYTICS\n\u251c\u2500 id (INTEGER, PRIMARY KEY AUTOINCREMENT)\n\u251c\u2500 steamid (TEXT)\n\u251c\u2500 contract_code (TEXT)\n\u251c\u2500 event_type (TEXT)\n\u251c\u2500 amount_loaned (REAL DEFAULT 0)\n\u251c\u2500 amount_received (REAL DEFAULT 0)\n\u251c\u2500 open_balance (REAL DEFAULT 0)\n\u2514\u2500 timestamp (INTEGER)\n</code></pre> <p>Purpose: - Records events such as contract creation, payments received, and open balance changes. - Feeds time-series charts and KPI aggregation client-side.</p> <p>Notes: - <code>timestamp</code> is stored as Unix time (INTEGER) for ordering and charting. - Cleanup routines may limit the number of tracked contracts per player and remove orphaned analytics.</p>"},{"location":"api/contract-model/#4-auto-loan-configuration-lshark_autolend","title":"4) Auto-Loan Configuration: <code>LSHARK_AUTOLEND</code>","text":"<p>Stores per-creditor auto-loan settings.</p> <pre><code>LSHARK_AUTOLEND\n\u251c\u2500 steamid (TEXT, PRIMARY KEY)\n\u251c\u2500 max_loan (REAL DEFAULT 0)\n\u251c\u2500 max_installments (INTEGER DEFAULT 1)\n\u251c\u2500 penalty_rate (REAL DEFAULT 0)\n\u2514\u2500 interest_rate (REAL DEFAULT 0)\n</code></pre> <p>Purpose: - Defines automatic loan constraints per lender (credit limit, installment cap, rates). - Used by the auto-loan request/validation flow server-side and for client preview UI.</p>"},{"location":"api/contract-model/#5-debtor-auto-debit-limit-lshark_debtor_limits","title":"5) Debtor Auto-Debit Limit: <code>LSHARK_DEBTOR_LIMITS</code>","text":"<p>Stores per-debtor automatic debit configuration.</p> <pre><code>LSHARK_DEBTOR_LIMITS\n\u251c\u2500 id (INTEGER, PRIMARY KEY AUTOINCREMENT)\n\u251c\u2500 steamid (TEXT NOT NULL UNIQUE)\n\u251c\u2500 balance_limit (INTEGER DEFAULT 100)\n\u2514\u2500 updated_at (TEXT)\n</code></pre> <p>Purpose: - Controls how much of a debtor\u2019s available balance is eligible for automatic collection. - Read/write is server-authoritative; UI only requests/updates via network messages.</p>"},{"location":"api/contract-model/#6-capped-contract-registry-lshark_limited_contracts","title":"6) Capped Contract Registry: <code>LSHARK_LIMITED_CONTRACTS</code>","text":"<p>Tracks contracts that have been marked as limited/capped.</p> <pre><code>LSHARK_LIMITED_CONTRACTS\n\u251c\u2500 contract_code (TEXT, PRIMARY KEY)\n\u2514\u2500 created_at (TEXT)\n</code></pre> <p>Purpose: - Maintains a durable record of contracts that reached the multiplier ceiling. - Allows consistent enforcement and auditing of capped behavior across restarts.</p>"},{"location":"api/contract-model/#indexes-performance","title":"Indexes (Performance)","text":"<p>LSHARK creates indexes for common queries:</p> <ul> <li>Contract lookups by creditor SteamID and debtor SteamID</li> <li>Log lookups by steamid and contract_code</li> <li>Analytics lookups by steamid</li> <li>Limited-contract lookups by contract_code</li> </ul> <p>These indexes keep contract retrieval, UI refreshes, and periodic maintenance efficient even with large datasets.</p>"},{"location":"api/contract-model/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>LSHARK treats SteamIDs as the stable identity keys for parties and balance owners.</li> <li>Contracts, logs, and analytics are designed so that contract_code links related records across tables.</li> <li>Clients never write directly to persistence; all mutations occur server-side and are validated before being saved.</li> </ul>"},{"location":"api/functions/","title":"Public API \u2014 Server Functions (<code>LSHARK.API</code>)","text":"<p>This section documents the public, server-side, read-only API exposed by LSHARK for third-party addon integration. The goal is to allow external systems (inventories, restrictions, analytics, admin tools) to observe contract state without direct access to internal SQL, net messages, or business logic.</p>"},{"location":"api/functions/#availability-scope","title":"Availability &amp; Scope","text":"<ul> <li>Server-side only (the module does not load on client).</li> <li>Read-only access to contract data (no create/update/delete functions).</li> <li>All contract payloads returned to addons are sanitized copies, so integrations don\u2019t depend on internal DB schemas or row formats.</li> </ul>"},{"location":"api/functions/#data-model-returned-by-the-api","title":"Data Model Returned by the API","text":"<p>All functions that return contract data use the same sanitized contract structure.</p> <pre><code>Contract (sanitized)\n\u251c\u2500 code (string)\n\u251c\u2500 creditor (string)\n\u251c\u2500 creditor_steamid (string)\n\u251c\u2500 debtor (string)\n\u251c\u2500 debtor_steamid (string)\n\u251c\u2500 creditor_job (string)\n\u251c\u2500 amount (number)                    -- principal\n\u251c\u2500 interest (number)                  -- percent\n\u251c\u2500 fine (number)                      -- percent\n\u251c\u2500 installments (number)\n\u251c\u2500 installments_paid (number)\n\u251c\u2500 installments_advanced (number)\n\u251c\u2500 total_with_interest (number)\n\u251c\u2500 total_paid (number)\n\u251c\u2500 remaining_balance (number)\n\u251c\u2500 status (string)                    -- \"active\", \"paused\", \"paid\", \"capped\", \"unknown\", etc.\n\u2514\u2500 created_at (any)                   -- forwarded from storage layer (if available)\n</code></pre> <p>Notes: - Numeric fields are normalized (e.g., <code>tonumber(...) or 0/1</code>) so external code can treat them safely as numbers. - <code>status</code> is always returned as a string (defaults to <code>\"unknown\"</code> if missing).</p>"},{"location":"api/functions/#function-reference","title":"Function Reference","text":""},{"location":"api/functions/#lsharkapigetallcontractscode","title":"<code>LSHARK.API.GetAllContractsCode()</code>","text":"<p>Returns a list of all contract codes in the database. Intended for admin/audit addons.</p> <p>Signature</p> <pre><code>local codes = LSHARK.API.GetAllContractsCode()\n</code></pre> <p>Returns - <code>codes</code> (<code>table&lt;string&gt;</code>): zero or more contract codes.</p> <p>Notes - This is an administrative-scope call. Avoid frequent execution on busy servers.</p>"},{"location":"api/functions/#lsharkapigetallcontractdata","title":"<code>LSHARK.API.GetAllContractData()</code>","text":"<p>Returns sanitized data for all contracts. This is a heavy operation and should be used only for admin panels or infrequent reporting.</p> <p>Signature</p> <pre><code>local all = LSHARK.API.GetAllContractData()\n</code></pre> <p>Returns - <code>all</code> (<code>table&lt;Contract&gt;</code>): array of sanitized contracts.</p> <p>Notes - Do not run per-tick or per-player. Prefer targeted calls (<code>GetContractsCode</code>, <code>GetContractData</code>).</p>"},{"location":"api/functions/#lsharkapigetcontractscodesteamid","title":"<code>LSHARK.API.GetContractsCode(steamid)</code>","text":"<p>Returns all contract codes related to a SteamID, including contracts where the player is debtor or creditor. Results are de-duplicated.</p> <p>Signature</p> <pre><code>local codes = LSHARK.API.GetContractsCode(\"STEAM_0:1:123456\")\n</code></pre> <p>Parameters - <code>steamid</code> (<code>string</code>): SteamID to query. Empty/invalid returns <code>{}</code>.</p> <p>Returns - <code>codes</code> (<code>table&lt;string&gt;</code>): unique contract codes.</p> <p>Behavior - Collects codes from:   - contracts where <code>steamid</code> is the debtor   - contracts where <code>steamid</code> is the creditor - Removes duplicates (same contract can match both sides in edge cases).</p>"},{"location":"api/functions/#lsharkapigetcontractdatacode","title":"<code>LSHARK.API.GetContractData(code)</code>","text":"<p>Returns sanitized contract data for a single contract code (or <code>nil</code> if not found).</p> <p>Signature</p> <pre><code>local c = LSHARK.API.GetContractData(\"ABC-12345\")\n</code></pre> <p>Parameters - <code>code</code> (<code>string</code>): contract code. Empty/invalid returns <code>nil</code>.</p> <p>Returns - <code>Contract|nil</code>: sanitized contract table, or <code>nil</code> if it doesn\u2019t exist.</p>"},{"location":"api/functions/#lsharkapigetbalancesteamid","title":"<code>LSHARK.API.GetBalance(steamid)</code>","text":"<p>Returns the internal LSHARK balance of a player. This is the balance used by LSHARK for lending operations and is not the DarkRP wallet balance.</p> <p>Signature</p> <pre><code>local balance = LSHARK.API.GetBalance(\"STEAM_0:1:123456\")\n</code></pre> <p>Parameters - <code>steamid</code> (<code>string</code>): Player SteamID. Empty or invalid values return <code>0</code>.</p> <p>Returns - <code>number</code>: Current LSHARK internal balance (always \u2265 0).</p> <p>Notes - This value represents the lender\u2019s internal funds stored by LSHARK. - It is used when issuing contracts and when receiving installment payments. - External addons must use this function instead of accessing database helpers directly.</p>"},{"location":"api/functions/#lsharkapihasactivedebtsteamid","title":"<code>LSHARK.API.HasActiveDebt(steamid)</code>","text":"<p>Returns <code>true</code> if the SteamID has any debt as debtor, defined by: - <code>remaining_balance &gt; 0</code>, and - <code>status ~= \"paid\"</code></p> <p>Signature</p> <pre><code>local hasDebt = LSHARK.API.HasActiveDebt(\"STEAM_0:1:123456\")\n</code></pre> <p>Parameters - <code>steamid</code> (<code>string</code>): debtor SteamID. Empty/invalid returns <code>false</code>.</p> <p>Returns - <code>boolean</code>: whether any non-paid contract still has remaining balance.</p> <p>Notes - This is the recommended helper for restrictions (job changes, purchases, rentals) when you only need a yes/no answer.</p>"},{"location":"api/functions/#usage-examples-server-side","title":"Usage Examples (Server-Side)","text":""},{"location":"api/functions/#example-1-block-an-action-if-player-has-debt","title":"Example 1 \u2014 Block an action if player has debt","text":"<pre><code>hook.Add(\"PlayerCanBuyPistol\", \"LSHARK_BlockIfDebt\", function(ply)\n    if not IsValid(ply) then return end\n    if LSHARK.API.HasActiveDebt(ply:SteamID()) then return false, \"You cannot buy this while in debt.\" end\nend)\n</code></pre>"},{"location":"api/functions/#example-2-fetch-all-contracts-for-a-player-and-print-remaining-balance","title":"Example 2 \u2014 Fetch all contracts for a player and print remaining balance","text":"<pre><code>local function DebugPrintPlayerContracts(ply)\n    if not IsValid(ply) then return end\n    local codes = LSHARK.API.GetContractsCode(ply:SteamID())\n    for _, code in ipairs(codes) do\n        local c = LSHARK.API.GetContractData(code)\n        if c then print(\"[LSHARK API]\", c.code, c.status, c.remaining_balance) end\n    end\nend\n</code></pre>"},{"location":"api/functions/#example-3-admin-scan-heavy-list-all-contract-codes","title":"Example 3 \u2014 Admin scan (heavy): list all contract codes","text":"<pre><code>concommand.Add(\"lshark_admin_list_codes\", function(ply)\n    if IsValid(ply) and not ply:IsAdmin() then return end\n    local codes = LSHARK.API.GetAllContractsCode()\n    print(\"[LSHARK API] Total contracts:\", #codes)\nend)\n</code></pre>"},{"location":"api/functions/#best-practices-for-integrators","title":"Best Practices for Integrators","text":"<ul> <li>Prefer targeted queries: <code>GetContractsCode(steamid)</code> + <code>GetContractData(code)</code>.</li> <li>Use <code>GetAllContractData()</code> only for admin-only panels or periodic exports.</li> <li>For restrictions, prefer <code>HasActiveDebt()</code> over manual status checks, because it encodes the rule \u201cremaining &gt; 0 and not paid\u201d.</li> <li>Avoid caching contract tables for long periods; prefer refreshing on LSHARK hooks (e.g., <code>LSHARK_ContractCreated</code>, <code>LSHARK_ContractPaidOff</code>, <code>LSHARK_ContractStatusChanged</code>).</li> </ul>"},{"location":"api/hooks/","title":"Public Hooks API (Server) \u2014 Contract Lifecycle Events","text":"<p>This document defines the public hook interface exposed by LSHARK for third-party integrations. Hooks are the recommended integration surface for addons that need to react to contract lifecycle changes without touching internal database, networking, or business logic.</p> <p>All hooks are emitted server-side using:</p> <ul> <li><code>hook.Run(\"&lt;HookName&gt;\", ...)</code></li> </ul> <p>Consumers subscribe using:</p> <ul> <li><code>hook.Add(\"&lt;HookName&gt;\", \"&lt;UniqueListenerID&gt;\", function(...) ... end)</code></li> </ul>"},{"location":"api/hooks/#design-rules-integration-contract","title":"Design Rules (Integration Contract)","text":"<ul> <li>Hooks are server-only signals. Client addons should not rely on them.</li> <li>Hook parameters are intentionally minimal and stable.</li> <li>Hooks are emitted after the authoritative action is validated and applied (and persisted when applicable).</li> <li>Hooks do not return values and do not affect execution flow (LSHARK does not read hook return values).</li> </ul>"},{"location":"api/hooks/#hook-list","title":"Hook List","text":""},{"location":"api/hooks/#1-lshark_contractcreated","title":"1) <code>LSHARK_ContractCreated</code>","text":"<p>When it fires After a debtor accepts a pending contract and the server: - transfers funds - persists the contract - activates it (<code>status = \"active\"</code>)</p> <p>Signature</p> <pre><code>hook.Run(\"LSHARK_ContractCreated\", contractTable)\n</code></pre> <p>Parameters - <code>contractTable</code> (table): Full contract snapshot as stored by LSHARK at creation time.</p> <p>Contract table contains (typical keys)</p> <pre><code>code, creditor, creditor_steamid, debtor, debtor_steamid, creditor_job,\namount, interest, fine, installments,\ninstallments_paid, installments_advanced,\ntotal_with_interest, total_paid, remaining_balance, status\n</code></pre> <p>Notes - This is the main entry point for external systems (logging, restrictions, job tools). - Fired only when the contract becomes authoritative (not when proposal is staged).</p>"},{"location":"api/hooks/#2-lshark_installmentpaid","title":"2) <code>LSHARK_InstallmentPaid</code>","text":"<p>When it fires Whenever a payment is successfully applied to a contract as an installment-related progression, including: - automatic full installment payments (auto-collect) - manual payments that progress installment state</p> <p>Signature</p> <pre><code>hook.Run(\"LSHARK_InstallmentPaid\", code)\n</code></pre> <p>Parameters - <code>code</code> (string): Contract code</p> <p>Notes - The hook signals that the contract\u2019s payment progress moved forward. - The payment amount is not included in this hook; consumers should query via API if needed.</p>"},{"location":"api/hooks/#3-lshark_fineapplied","title":"3) <code>LSHARK_FineApplied</code>","text":"<p>When it fires When a fine is applied due to: - automatic payment failure (no funds / no debit cap) - partial payment where fine rules are applicable (not capped)</p> <p>Signature</p> <pre><code>hook.Run(\"LSHARK_FineApplied\", code)\n</code></pre> <p>Parameters - <code>code</code> (string): Contract code</p> <p>Notes - Not fired when the contract is already <code>capped</code> (fines are disabled in capped mode). - Only indicates that a fine was applied; values must be queried if needed.</p>"},{"location":"api/hooks/#4-lshark_limitedcontract","title":"4) <code>LSHARK_LimitedContract</code>","text":"<p>When it fires When a contract becomes capped/limited due to reaching the multiplier ceiling. The server clamps remaining balance and disables fines.</p> <p>Signature</p> <pre><code>hook.Run(\"LSHARK_LimitedContract\", code)\n</code></pre> <p>Parameters - <code>code</code> (string): Contract code</p> <p>Notes - Fired on the transition into capped mode (not on every tick while capped). - Indicates that contract escalation has been permanently bounded.</p>"},{"location":"api/hooks/#5-lshark_contractpaidoff","title":"5) <code>LSHARK_ContractPaidOff</code>","text":"<p>When it fires When a contract reaches full settlement and becomes paid: - remaining balance reaches 0 - status becomes <code>paid</code></p> <p>Occurs in: - auto-collection final installment - manual pay flow when final payment completes the debt</p> <p>Signature</p> <pre><code>hook.Run(\"LSHARK_ContractPaidOff\", code)\n</code></pre> <p>Parameters - <code>code</code> (string): Contract code</p> <p>Notes - Fired after persistence updates are applied. - Useful for removing restrictions, releasing collateral, granting rewards, etc.</p>"},{"location":"api/hooks/#6-lshark_contractdeleted","title":"6) <code>LSHARK_ContractDeleted</code>","text":"<p>When it fires When a contract is deleted by: - the creditor (owner delete) - an admin action</p> <p>Deletion includes: - contract row removal - associated logs cleanup - associated analytics cleanup</p> <p>Signature</p> <pre><code>hook.Run(\"LSHARK_ContractDeleted\", code)\n</code></pre> <p>Parameters - <code>code</code> (string): Contract code</p> <p>Notes - Fired after the delete has been applied server-side. - Consumers should treat this as final and remove any cached state.</p>"},{"location":"api/hooks/#7-lshark_contractstatuschanged","title":"7) <code>LSHARK_ContractStatusChanged</code>","text":"<p>When it fires When the creditor toggles a contract status and the change is persisted. Typical transitions include: - <code>active \u2194 paused</code> - <code>capped \u2194 paused</code> (for limited contracts) - other policy-driven status flips (excluding <code>paid</code>, which is terminal)</p> <p>Signature</p> <pre><code>hook.Run(\"LSHARK_ContractStatusChanged\", code, oldStatus, newStatus)\n</code></pre> <p>Parameters - <code>code</code> (string): Contract code - <code>oldStatus</code> (string): Previous status (lowercased in toggle path) - <code>newStatus</code> (string): New persisted status</p> <p>Notes - Fired only after persistence succeeds. - If the contract is limited, status toggling respects capped behavior rules.</p>"},{"location":"api/hooks/#typical-use-cases","title":"Typical Use Cases","text":"<ul> <li>Restriction systems: lock doors, block job changes, or apply penalties while contracts are active.</li> <li>Economy integrations: tax, fee sharing, or alternative wallet bridges.</li> <li>Discord / Webhook relays: broadcast contract events in external systems.</li> <li>Administrative tooling: dashboards that react live to state changes.</li> </ul>"},{"location":"api/hooks/#minimal-example-tester-pattern","title":"Minimal Example (Tester Pattern)","text":"<pre><code>hook.Add(\"LSHARK_ContractCreated\",\"MyAddon_OnCreated\",function(contract)\n    print(\"[MyAddon] contract created:\", contract.code, contract.creditor_steamid, contract.debtor_steamid)\nend)\n\nhook.Add(\"LSHARK_ContractPaidOff\",\"MyAddon_OnPaid\",function(code)\n    print(\"[MyAddon] contract paid off:\", code)\nend)\n\nhook.Add(\"LSHARK_ContractStatusChanged\",\"MyAddon_OnStatus\",function(code, oldStatus, newStatus)\n    print(\"[MyAddon] status changed:\", code, oldStatus, \"-&gt;\", newStatus)\nend)\n</code></pre>"},{"location":"api/hooks/#compatibility-notes","title":"Compatibility Notes","text":"<ul> <li>Hook names and parameter order must be treated as part of the public API.</li> <li>Integrations should avoid mutating the <code>contractTable</code> reference received in hooks.</li> <li>If an integration needs amounts or extra fields beyond the hook parameters, it should query the public server API (<code>LSHARK.API</code>) rather than reading internal DB tables directly.</li> </ul>"},{"location":"api/lifecycle/","title":"Contract Lifecycle \u2014 Creation &amp; Automatic Collection","text":"<p>This document consolidates the LSHARK contract lifecycle into a single, cohesive explanation covering: - Part 1: Contract creation, delivery, and acceptance - Part 2: Automatic debt collection (auto-collection), including partial payments, fines, and caps</p> <p>The lifecycle is designed around server authority, explicit debtor consent, and auditable state transitions.</p>"},{"location":"api/lifecycle/#part-1-creation-delivery-and-acceptance","title":"Part 1 \u2014 Creation, Delivery, and Acceptance","text":""},{"location":"api/lifecycle/#1-proposal-creation-creditor","title":"1) Proposal Creation (Creditor)","text":"<p>A contract begins as a proposal initiated by the creditor.</p> <p>Manual contracts - Created from the lender UI (Management tab). - The client builds a proposal and sends it to the server.</p> <p>Auto-loans - Initiated via the server-side auto-loan subsystem. - Auto-loans are validated against the creditor configuration and then issued through the same contract manager path.</p>"},{"location":"api/lifecycle/#2-server-reception-validation-authority","title":"2) Server Reception &amp; Validation (Authority)","text":"<p>On manual proposal submission, the server receives:</p> <ul> <li>Net message: <code>LSHARK_Contract_Send</code></li> </ul> <p>Manual payload (conceptual order)</p> <pre><code>LSHARK_Contract_Send\n\u251c\u2500 code (string)\n\u251c\u2500 creditor_name (string)        -- display-only, server re-validates\n\u251c\u2500 debtor_name (string)          -- used to resolve target player\n\u251c\u2500 amount (float)                -- principal\n\u251c\u2500 interest (float)              -- interest percent\n\u251c\u2500 fine (float)                  -- fine percent\n\u251c\u2500 total_with_interest (float)   -- client preview (server still validates)\n\u2514\u2500 installments (uint16)\n</code></pre> <p>The server is authoritative and validates: - creditor identity and job permission - debtor resolution (must be online and valid) - self-contract restrictions (unless debug) - job limits (interest, fine, installments, multiplier cap) - creditor internal balance availability</p> <p>If any check fails, the proposal is rejected and the creditor is notified.</p>"},{"location":"api/lifecycle/#3-pending-staging-no-persistence-yet","title":"3) Pending Staging (No Persistence Yet)","text":"<p>Approved proposals are staged in memory as pending contracts:</p> <ul> <li><code>PENDING_CONTRACTS[code] = contractTable</code></li> </ul> <p>This ensures: - no contract is persisted without debtor consent - rejected/expired offers are discarded without touching storage</p> <p>Pending states typically include: - <code>pending</code> for manual proposals - <code>auto_pending</code> for auto-loans - <code>origin</code> metadata to track issuance source</p>"},{"location":"api/lifecycle/#4-delivery-to-debtor-server-client","title":"4) Delivery to Debtor (Server \u2192 Client)","text":"<p>The server sends the offer to the debtor:</p> <ul> <li>Net message: <code>LSHARK_Contract_Receive</code></li> </ul> <p>Delivery payload (conceptual)</p> <pre><code>LSHARK_Contract_Receive\n\u251c\u2500 code (string)\n\u251c\u2500 creditor (string)\n\u251c\u2500 creditor_steamid (string)\n\u251c\u2500 debtor (string)\n\u251c\u2500 debtor_steamid (string)\n\u251c\u2500 amount (float)\n\u251c\u2500 interest (float)\n\u251c\u2500 fine (float)\n\u251c\u2500 installments (uint16)\n\u2514\u2500 total_with_interest (float)\n</code></pre> <p>This payload is intentionally minimal and UI-oriented.</p>"},{"location":"api/lifecycle/#5-debtor-decision-accept-reject","title":"5) Debtor Decision (Accept / Reject)","text":"<p>On the client: - Auto-loans (<code>AUTO-...</code>) open the signing UI immediately. - Manual offers show a notification with quick actions (open/accept or reject).</p> <p>The debtor responds with one of:</p> <ul> <li><code>LSHARK_Contract_Accept</code> (payload: <code>code</code>)</li> <li><code>LSHARK_Contract_Reject</code> (payload: <code>code</code>)</li> </ul>"},{"location":"api/lifecycle/#6-acceptance-finalization-server","title":"6) Acceptance Finalization (Server)","text":"<p>When the debtor accepts, the server:</p> <ol> <li>validates pending existence and debtor ownership</li> <li>re-checks creditor balance availability</li> <li>transfers money:</li> <li>deduct principal from creditor internal balance</li> <li>credit principal to debtor DarkRP wallet</li> <li>persists the contract:</li> <li><code>status = \"active\"</code></li> <li><code>LSHARK.DB_InsertContract(contractTable)</code></li> <li>emits:</li> <li><code>hook.Run(\"LSHARK_ContractCreated\", contractTable)</code></li> <li>registers:</li> <li>logs (audit)</li> <li>analytics (timeline)</li> <li>notifies both parties</li> <li>removes the pending record</li> </ol> <p>Rejection simply removes the pending record and notifies the creditor, with no persistence and no transfer.</p>"},{"location":"api/lifecycle/#part-2-automatic-debt-collection-auto-collect","title":"Part 2 \u2014 Automatic Debt Collection (Auto-Collect)","text":"<p>Automatic collection is the enforcement stage that processes active contracts over time. It is fully server-authoritative and runs periodically for online debtors.</p> <p>Before each collection cycle, LSHARK gathers every contract where the online player is the debtor and the contract is eligible for enforcement (<code>active</code> or <code>capped</code>). For each contract, the server first normalizes the financial state (remaining balance, total paid, installment counters) and applies protective rules that keep the system stable over time.</p> <p>The first protection is the debt ceiling (multiplier cap). If the contract\u2019s remaining balance has grown beyond the maximum allowed for the creditor job, LSHARK clamps the remaining balance to that ceiling, switches the contract into <code>capped</code>, and disables late fees (<code>fine = 0</code>). From that point forward, the contract can still be paid down, but it can no longer grow due to penalties.</p> <p>Once the contract is inside allowed bounds, the server determines what the debtor is allowed to pay automatically in this tick by computing the auto-debit cap from the debtor\u2019s current DarkRP wallet balance and their configured percentage limit. This cap is a hard limit for the tick: LSHARK will not auto-debit more than that amount, even if the contract is behind.</p> <p>With the cap established, LSHARK computes the current installment target based on the remaining balance divided by the number of installments still open. Then it processes one of the three payment outcomes. If the debtor has enough available cap to cover the target installment, the server debits the debtor\u2019s DarkRP wallet and credits the same value into the creditor\u2019s internal LSHARK balance, advances the installment counter, reduces the remaining balance, and if the remaining reaches zero it marks the contract as <code>paid</code>. If the debtor can pay something but not the full target installment, the server still debits what it can (up to the cap), credits the creditor\u2019s LSHARK balance, reduces the remaining balance, and then evaluates penalty rules.</p> <p>Late fees are applied only when the contract is not capped and the fine percentage is greater than zero. They occur when the debtor cannot meet the expected payment for the tick (for example: no available cap, no wallet money, or only a partial payment). In those cases, LSHARK increases the remaining balance by a fine computed from the remaining amount under the configured fine rate, persists the updated remaining balance, and emits the corresponding hooks/logs/analytics. If the contract is <code>capped</code>, the same failure or partial-payment scenarios do not apply any fine; the system only records the event and continues.</p> <p>All money movement is strictly server-side and always follows the same direction: payments are taken from the debtor\u2019s DarkRP wallet and deposited into the creditor\u2019s LSHARK internal balance. No client-side calculation or UI action can force these transitions; the client only observes the results through updates, notifications, and events.</p>"},{"location":"api/lifecycle/#1-timer-scheduling","title":"1) Timer &amp; Scheduling","text":"<p>The engine runs on a repeating timer:</p> <ul> <li><code>LSHARK_AutoCollectTimer</code></li> </ul> <p>It is started (and restarted) on: - <code>InitPostEntity</code> - <code>PostCleanupMap</code></p> <p>Its interval is configured by:</p> <ul> <li><code>Settings.General.AutoDebtProcessingInterval</code></li> </ul>"},{"location":"api/lifecycle/#2-eligibility-rules","title":"2) Eligibility Rules","text":"<p>On each cycle, the server processes contracts for each online player where: - <code>debtor_steamid == ply:SteamID()</code></p> <p>Eligible statuses: - <code>active</code> - <code>capped</code></p> <p>Skipped: - <code>paused</code> - <code>paid</code></p>"},{"location":"api/lifecycle/#3-debtor-auto-debit-limit-cap","title":"3) Debtor Auto-Debit Limit (Cap)","text":"<p>Before debiting money, the engine computes the debtor cap:</p> <ol> <li>debtor wallet:</li> <li><code>wallet = ply:getDarkRPVar(\"money\")</code></li> <li>percent limit:</li> <li>debtor-specific limit if stored</li> <li>otherwise fallback to <code>Settings.General.DefaultDebtDiscount</code></li> <li>final debit cap:</li> <li><code>debitCap = floor(wallet * (pct / 100))</code></li> </ol> <p>This prevents auto-collection from consuming more than the debtor configured as eligible.</p>"},{"location":"api/lifecycle/#4-installment-target-computation","title":"4) Installment Target Computation","text":"<p>For an eligible contract, installment target is computed from remaining balance:</p> <pre><code>installmentsRemaining = max(installments - installments_paid, 1)\ntargetInstallment     = remaining_balance / installmentsRemaining\n</code></pre> <p>This keeps installments adaptive as remaining balance changes (including fines and partials).</p>"},{"location":"api/lifecycle/#5-debt-cap-enforcement-multiplier-ceiling","title":"5) Debt Cap Enforcement (Multiplier Ceiling)","text":"<p>Before fines and before progressing, the engine ensures the contract does not exceed the maximum debt multiplier:</p> <ul> <li><code>cap = amount * MaxLoanMultiplier</code> (from job limits)</li> </ul> <p>If the contract exceeds cap: - remaining is clamped to cap - fine is set to <code>0</code> (late fee disabled) - status becomes <code>capped</code> - the contract is recorded as limited - hooks/logs/analytics are emitted</p> <p>This prevents infinite debt escalation.</p>"},{"location":"api/lifecycle/#6-processing-outcomes","title":"6) Processing Outcomes","text":"<p>The engine chooses one of the following paths:</p>"},{"location":"api/lifecycle/#a-no-money-available-failure-path","title":"A) No money available (failure path)","text":"<p>If <code>wallet &lt;= 0</code> or <code>debitCap &lt;= 0</code>: - if status is <code>capped</code>: no fine, just notify/log - if status is <code>active</code> and fine &gt; 0: apply late fee on remaining balance and persist - if status is <code>active</code> and fine == 0: persist unchanged, notify/log</p>"},{"location":"api/lifecycle/#b-full-installment-payment","title":"B) Full installment payment","text":"<p>If <code>debitCap &gt;= targetInstallment</code>: - debit installment value - credit creditor internal balance - increment <code>installments_paid</code> - reduce <code>remaining_balance</code> - if settled: set <code>status = \"paid\"</code>, set remaining to 0, emit payoff hook</p> <p>Hooks/logs/analytics and notifications are emitted for the installment payment.</p>"},{"location":"api/lifecycle/#c-partial-payment","title":"C) Partial payment","text":"<p>If <code>debitCap &gt; 0</code> but <code>&lt; targetInstallment</code>: - debit partial amount - credit creditor internal balance - reduce remaining balance by partial - if active and fine &gt; 0: apply fine on the new remaining - if capped: no fine</p> <p>Persist, notify, and emit logs/analytics accordingly.</p>"},{"location":"api/lifecycle/#d-advanced-installment-consumption-if-present","title":"D) Advanced installment consumption (if present)","text":"<p>If <code>installments_advanced &gt; 0</code>, the engine consumes one advanced installment for that tick: - decreases <code>installments_advanced</code> - persists updated value - emits logs/analytics - no money transfer and no fine</p>"},{"location":"api/lifecycle/#7-persistence-consistency","title":"7) Persistence &amp; Consistency","text":"<p>Every enforcement tick persists a consistent snapshot using the contract storage layer. Updates typically include: - <code>total_paid</code> - <code>remaining_balance</code> - <code>installments_paid</code> - <code>installments_advanced</code> - <code>fine</code> (possibly disabled when capped) - <code>status</code> transitions: <code>active \u2192 capped</code>, <code>active/capped \u2192 paid</code></p> <p>This ensures restarts do not break progression and all state remains durable.</p>"},{"location":"api/lifecycle/#8-auditability-extensibility","title":"8) Auditability &amp; Extensibility","text":"<p>Auto-collection emits: - notifications to debtors and (when online) creditors - logs for every major event - analytics events for the dashboard timeline - lifecycle hooks for third-party integrations</p> <p>Common hooks include: - <code>LSHARK_LimitedContract(code)</code> - <code>LSHARK_FineApplied(code)</code> - <code>LSHARK_InstallmentPaid(code)</code> - <code>LSHARK_ContractPaidOff(code)</code></p>"},{"location":"api/lifecycle/#summary","title":"Summary","text":"<p>The LSHARK lifecycle is built to guarantee: - server authority over every state transition - debtor consent before persistence and money transfer - bounded enforcement via debtor debit caps and multiplier ceilings - durable persistence on every meaningful update - full observability through notifications, logs, analytics, and hooks</p>"},{"location":"api/overview/","title":"API Overview","text":""},{"location":"api/overview/#contract-structure-authoritative-model","title":"Contract Structure (Authoritative Model)","text":"<p>A contract is the central authoritative object in LSHARK. It represents a loan agreement between a creditor and a debtor, fully enforced server-side.</p>"},{"location":"api/overview/#core-fields","title":"Core Fields","text":"<pre><code>Contract\n\u251c\u2500 code                     -- unique contract identifier\n\u251c\u2500 creditor                 -- display name\n\u251c\u2500 creditor_steamid          -- stable owner identifier\n\u251c\u2500 debtor                   -- display name\n\u251c\u2500 debtor_steamid            -- stable beneficiary identifier\n\u251c\u2500 creditor_job              -- job at creation time\n\u251c\u2500 amount                   -- principal\n\u251c\u2500 interest                 -- interest percentage\n\u251c\u2500 fine                     -- late fee percentage\n\u251c\u2500 installments             -- total installments\n\u251c\u2500 installments_paid        -- completed installments\n\u251c\u2500 installments_advanced    -- prepaid/covered installments\n\u251c\u2500 total_with_interest      -- final debt value\n\u251c\u2500 total_paid               -- accumulated payments\n\u251c\u2500 remaining_balance        -- unpaid balance\n\u251c\u2500 status                   -- active | paused | capped | paid\n\u2514\u2500 created_at               -- creation timestamp\n</code></pre>"},{"location":"api/overview/#example-conceptual","title":"Example (Conceptual)","text":"<pre><code>{\n  code = \"AUTO-123456\",\n  creditor = \"Banker Bob\",\n  creditor_steamid = \"STEAM_0:1:11111111\",\n  debtor = \"Player Alice\",\n  debtor_steamid = \"STEAM_0:0:22222222\",\n  creditor_job = \"Banker\",\n  amount = 5000,\n  interest = 40,\n  fine = 2,\n  installments = 10,\n  installments_paid = 3,\n  installments_advanced = 3,\n  total_with_interest = 7000,\n  total_paid = 2100,\n  remaining_balance = 4900,\n  status = \"active\"\n}\n</code></pre>"},{"location":"api/overview/#hooks-event-surface","title":"Hooks (Event Surface)","text":"<p>Hooks are the primary reactive integration surface. They are server-side, fire after authoritative state changes, and never affect execution flow.</p>"},{"location":"api/overview/#available-hooks","title":"Available Hooks","text":"<pre><code>LSHARK_ContractCreated(contractTable)\nLSHARK_InstallmentPaid(code)\nLSHARK_FineApplied(code)\nLSHARK_LimitedContract(code)\nLSHARK_ContractPaidOff(code)\nLSHARK_ContractDeleted(code)\nLSHARK_ContractStatusChanged(code, oldStatus, newStatus)\n</code></pre>"},{"location":"api/overview/#notes","title":"Notes","text":"<ul> <li>Hooks are emitted after validation and persistence.</li> <li><code>contractTable</code> is provided only on creation; all others reference by <code>code</code>.</li> <li>Use hooks to sync restrictions, logs, webhooks, or external systems.</li> </ul>"},{"location":"api/overview/#public-functions-lsharkapi","title":"Public Functions (<code>LSHARK.API</code>)","text":"<p>Functions provide read-only queries into the authoritative state. They never mutate contracts or balances.</p>"},{"location":"api/overview/#contract-queries","title":"Contract Queries","text":"<pre><code>GetAllContractsCode()            -&gt; table&lt;string&gt;\nGetAllContractData()             -&gt; table&lt;Contract&gt;\nGetContractsCode(steamid)        -&gt; table&lt;string&gt;\nGetContractData(code)            -&gt; Contract | nil\n</code></pre>"},{"location":"api/overview/#state-balance-helpers","title":"State &amp; Balance Helpers","text":"<pre><code>HasActiveDebt(steamid)           -&gt; boolean\nGetBalance(steamid)              -&gt; number\n</code></pre>"},{"location":"api/overview/#notes_1","title":"Notes","text":"<ul> <li><code>GetAllContractData()</code> is heavy and intended for admin usage only.</li> <li><code>HasActiveDebt()</code> encodes the rule: remaining_balance &gt; 0 and status != paid.</li> <li><code>GetBalance()</code> returns the LSHARK internal balance, not DarkRP money.</li> </ul>"},{"location":"api/overview/#integration-philosophy","title":"Integration Philosophy","text":"<ul> <li>Server-authoritative</li> <li>Event-driven via hooks</li> <li>Read-only data access via API</li> <li>No direct SQL or net usage required</li> </ul> <p>If you need to: - react \u2192 use hooks - query \u2192 use <code>LSHARK.API</code> - enforce rules \u2192 combine hooks + queries  </p> <p>This separation guarantees stability, forward compatibility, and safe third-party integration.</p>"}]}